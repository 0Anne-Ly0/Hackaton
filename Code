#Dichotomy
def dichotomie(f, a, b, e):
    while abs(b - a) >= e:
        m = (a + b)/2
        if f(a) * f(m) <= 0:
            b = m
        else:
            a = m
    return m

#Newton
def Newton(f, df, a, b, e):
    while abs(b - a) >= e :
        a, b = b, b - f(b)/df(b)
    return b

#Rectangle
def integrale_rectangle(f, a, b, n):
    h=(b-a)/n
    sum=0    #represents the sum
    for k in range(n):
        sum+=f(a+k*h)  #f(xk)
    return h*sum

#Simpson
def integrale_simpson(f,a,b,n):
    h=(b-a)/n
    sum_mk=0
    sum_xk=0
    
    for k in range(n):
        mk=((a+k*h)+(a+(k+1)*h))/2
        sum_mk += f(mk)
    
    for k in range(1,n):
        sum_xk+=f(a+k*h)
    
    s =f(a) +f(b)+4*sum_mk +2*sum_xk
    return h/6 *s

def f(x):
    return 3*x**2+2*x-1
print(f(3))
def df(x):
    return 6*x+2
print(df(3))

#Test dichotonomy
print(dichotomie(f, -3, 6, 0.001))

#Test Newton
print(Newton(f, df, -3, 6, 100))

#Test rectangle
print(integrale_rectangle(f, 3, 10, 55))

#Test simpson
print(integrale_simpson(f, 3, 10, 55))

#implementation of F
from math import *
from math import exp

def F(t,y):
    return (1/sqrt(2*pi))*exp(-(x**2)/2)

def euler (F, t0, tf, y0, n):
    h = (tf-t0)/n  # The step
    T = [t0] # The future subdivision
    Y = [y0] # The values of the various yi starting with y0
    for i in range(n):
        y = Y[-1]+ h* F(T[-1], Y[-1])  # Expression of y_{i+1} as a function of F, h and y_{i}
        t = t0+ i*h   # Move on to the next t by adding the step
        T.append(t)
        Y.append(y)
    return T, Y
