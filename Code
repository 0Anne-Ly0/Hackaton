#Dichotomy
def dichotomie(f, a, b, e):
    while abs(b - a) >= e:
        m = (a + b)/2
        if f(a) * f(m) <= 0:
            b = m
        else:
            a = m
    return m

#Newton
def Newton(f, df, a, b, e):
    while abs(b - a) >= e :
        a, b = b, b - f(b)/df(b)
    return b

#Rectangle
def integrale_rectangle(f, a, b, n):
    h=(b-a)/n
    sum=0    #represents the sum
    for k in range(n):
        sum+=f(a+k*h)  #f(xk)
    return h*sum

#Simpson
def integrale_simpson(f,a,b,n):
    h=(b-a)/n
    sum_mk=0
    sum_xk=0
    
    for k in range(n):
        mk=((a+k*h)+(a+(k+1)*h))/2
        sum_mk += f(mk)
    
    for k in range(1,n):
        sum_xk+=f(a+k*h)
    
    s =f(a) +f(b)+4*sum_mk +2*sum_xk
    return h/6 *s

def g(x):
    return 3*x**2+2*x-1
print(g(3))
def dg(x):
    return 6*x+2
print(dg(3))

#Test dichotonomy
print(dichotomie(g, -3, 6, 0.001))

#Test Newton
print(Newton(g, dg, -3, 6, 100))

#Test rectangle
print(integrale_rectangle(g, 3, 10, 55))

#Test simpson
print(integrale_simpson(g, 3, 10, 55))

#implementation of f
from math import *

def f(t,y):
    return (1/sqrt(2*pi))*exp(-(t**2)/2)

def Fbis(qp):
    return integrale_simpson(f,qp,10,100)
#Test of Fbis with the values of the given table
print(round(Fbis(3.0902),4))
print(round(Fbis(1.165),4))


def F(qp):
    return 1-integrale_simpson(f,-10, qp, 100)
#Test of F with the values of the given table
print(round(F(3.0902),4))
print(round(F(1.165),4))


#just in case
def euler (f, t0, tf, y0, n):
    h = (tf-t0)/n  # The step
    T = [t0] # The future subdivision
    Y = [y0] # The values of the various yi starting with y0
    for i in range(n):
        y = Y[-1]+ h* f(T[-1], Y[-1])  # Expression of y_{i+1} as a function of F, h and y_{i}
        t = t0+ i*h   # Move on to the next t by adding the step
        T.append(t)
        Y.append(y)
    return T, Y




#BONUS#
#Student's Law
import numpy as np
from matplotlib import pyplot as plt
from scipy import stats as st

# We want the distributions to appear on the plot from -3 to 3
x = np.linspace(-3, 3, 1000)
# The t-distribution for 1 degree of freedom
dof = 1
pdf_1 = st.t.pdf(x, dof)
# The t-distribution for 3 degrees of freedom
dof = 3
pdf_3 = st.t.pdf(x, dof)
# The t-distribution for 8 degrees of freedom
dof = 8
pdf_8 = st.t.pdf(x, dof)
# The t-distribution for 30 degrees of freedom
dof = 30
pdf_30 = st.t.pdf(x, dof)

# We want the distributions to appear on the plot from -3 to 3
x = np.linspace(-3, 3, 1000)
# The standard normal distribution
pdf_norm = st.norm.pdf(x)

# Set the seed so that we get the same random numbers each time this code runs
np.random.seed(20230811)
# Sample 1000 random numbers from the t-distribution with dof = 30
random_numbers = np.random.standard_t(30, 1000)

# As dof â‰¥ 3, the mean and standard deviation should be approximately 0 and 1
print(f'This should be close to zero: {random_numbers.mean()}')
print(f'This should be close to one: {random_numbers.std()}')

# Create plot
ax = plt.axes()
# Random numbers
label = '1000 Random Numbers'
ax.hist(random_numbers, density=True, label=label, color='gray', alpha=0.3)
# Probability density functions (PDFs)
ax.plot(x, pdf_norm, 'k', label='Standard Normal Distribution')
ax.plot(x, pdf_30, label='$t$-distribution, dof = 30')
ax.plot(x, pdf_8, label='$t$-distribution, dof = 8')
ax.plot(x, pdf_3, label='$t$-distribution, dof = 3')
ax.plot(x, pdf_1, label='$t$-distribution, dof = 1')
# Mean
ax.axvline(0, 0, st.norm.pdf(0) / 0.45, c='k', ls='--', label='Mean')
# Axes
ax.set_ylim([0, 0.45])
ax.set_xlim([-3, 3])
# Format
title = """Probability Density Functions (PDFs) of $t$-Distributions
and the Standard Normal Distribution"""
ax.set_title(title)
ax.set_ylabel('Relative Likelihood')
ax.set_xlabel('Distance of the Value of a Random Variable from the Mean')
ax.legend(frameon=False, fontsize='x-small')
plt.show()
